<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Firmware</title>
<link rel="stylesheet" href="./../../asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article">
<div id="header">
<h1>Firmware</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of contents</div>
<ul class="sectlevel1">
<li><a href="#_software_and_documentation">Software and documentation</a></li>
<li><a href="#_programmer_interface">Programmer interface</a></li>
<li><a href="#_gpio">GPIO</a>
<ul class="sectlevel2">
<li><a href="#_output">Output</a></li>
</ul>
</li>
<li><a href="#_usb">USB</a></li>
<li><a href="#_encoders">Encoders</a>
<ul class="sectlevel2">
<li><a href="#_stm32cubeide_timer_configuration">STM32CubeIDE timer configuration</a></li>
<li><a href="#_timer_code">Timer code</a></li>
</ul>
</li>
<li><a href="#_pwm">PWM</a>
<ul class="sectlevel2">
<li><a href="#_stm32cubeide_timer_configuration_2">STM32CubeIDE timer configuration</a></li>
<li><a href="#_frequency">Frequency</a></li>
<li><a href="#_pwm_for_wheel_motor_drivers">PWM for wheel motor drivers</a></li>
<li><a href="#_pwm_for_thrower_motor_driver">PWM for thrower motor driver</a></li>
<li><a href="#_pwm_code">PWM code</a></li>
</ul>
</li>
<li><a href="#_motor_control">Motor control</a>
<ul class="sectlevel2">
<li><a href="#_periodic_interrupt">Periodic interrupt</a></li>
<li><a href="#_pid_controller">PID controller</a></li>
</ul>
</li>
<li><a href="#_boot_configuration">Boot configuration</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_software_and_documentation">Software and documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide assumes that STM32CubeIDE and HAL libraries are used.</p>
</div>
<div class="paragraph">
<p><a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.st.com/resource/en/datasheet/stm32g441kb.pdf">STM32G441KB datasheet</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.st.com/resource/en/reference_manual/dm00355726-stm32g4-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32G4 series reference manual</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programmer_interface">Programmer interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Programmer interface can be enabled from <em>SYS &#8594; Debug: Serial Wire</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpio">GPIO</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_output">Output</h3>
<div class="paragraph">
<p>Pin can be changed to <em>GPIO_Output</em> in the <em>Pinout view</em> by left clicking on the pin.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/firmware_gpio_output.png" alt="GPIO output">
</div>
</div>
<div class="paragraph">
<p>Label can be added by right clicking on the pin and selecting <em>Enter User Label</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/firmware_gpio_output_label.png" alt="GPIO output">
</div>
</div>
<div class="paragraph">
<p>Pin output state can be changed with HAL_GPIO functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usb">USB</h2>
<div class="sectionbody">
<div class="paragraph">
<p>USB virtual serial port can be used to communicate with robot&#8217;s computer.</p>
</div>
<div class="paragraph">
<p>Enable by checking <em>USB &#8594; Device (FS)</em>
and selecting <em>USB_DEVICE &#8594; Class For FS IP: Communication Device Class (Virtual Port Com)</em>.</p>
</div>
<div class="paragraph">
<p>One option to implement USB communication is to send binary data that is defined by structs.
Binary communication is easier to implement and computationally more efficient than text based communication.</p>
</div>
<div class="listingblock">
<div class="title">usbd_cdc_if.h</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* USER CODE BEGIN EXPORTED_FUNCTIONS */
void CDC_On_Receive(uint8_t* buffer, uint32_t* length); // <b class="conum">(1)</b>
/* USER CODE END EXPORTED_FUNCTIONS */</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Declare a function to be called when data is received from USB.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">usbd_cdc_if.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  CDC_On_Receive(Buf, Len); // <b class="conum">(1)</b>
  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);
  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);
  return (USBD_OK);
  /* USER CODE END 6 */
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add call to the function in CDC_Receive_FS and pass pointers to data and length of data.
CDC_Receive_FS is a handler for incoming USB data.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* USER CODE BEGIN Includes */
#include "usbd_cdc_if.h" // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Include usbd_cdc_if.h, where the CDC_On_Receive function was declared.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* USER CODE BEGIN 0 */
typedef struct Command { // <b class="conum">(1)</b>
  int16_t speed1;
  int16_t speed2;
  int16_t speed3;
  uint16_t throwerSpeed;
  uint16_t delimiter; // <b class="conum">(2)</b>
} Command;

typedef struct Feedback { // <b class="conum">(3)</b>
  int16_t speed1;
  int16_t speed2;
  int16_t speed3;
  uint16_t delimiter;
} Feedback;

Command command = {.speed1 = 0, .speed2 = 0, .speed3 = 0, .throwerSpeed = 0, .delimiter = 0}; // <b class="conum">(4)</b>
volatile uint8_t isCommandReceived = 0; // <b class="conum">(5)</b>

void CDC_On_Receive(uint8_t* buffer, uint32_t* length) { // <b class="conum">(6)</b>
  if (*length == sizeof(Command)) { // <b class="conum">(7)</b>
    memcpy(&amp;command, buffer, sizeof(Command)); // <b class="conum">(8)</b>

    if (command.delimiter == 0xAAAA) { // <b class="conum">(9)</b>
      isCommandReceived = 1;
    }
  }
}
/* USER CODE END 0 */</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define struct for received data.</p>
</li>
<li>
<p>Delimiter is used as a separator between packets of data.
Preferably something that will never appear in the data should be used.</p>
</li>
<li>
<p>Define struct for sending data. This can be omitted if there is no need for data from mainboard.</p>
</li>
<li>
<p>Instance of received data.</p>
</li>
<li>
<p>Boolean (0/1) variable to signify that data has been received.
Variable is marked volatile to prevent the compiler from removing it during optimisation.</p>
</li>
<li>
<p>Define the function that is called when data is received.
It is usually preferable to keep interrupt handlers small and fast to avoid blocking other code from executing.
Only data copying and setting isCommandReceived to 1 is done in the handler.
Rest is handled in the main while loop.</p>
</li>
<li>
<p>Check if received data the has same length as Command struct.</p>
</li>
<li>
<p>Copy received data to command instance.</p>
</li>
<li>
<p>Check the delimiter as a validation of received data.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(void)
{
  // ...

  /* USER CODE BEGIN 2 */
  Feedback feedback = { // <b class="conum">(1)</b>
      .speed1 = 0,
      .speed2 = 0,
      .speed3 = 0,
      .delimiter = 0xAAAA
  };
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    if (isCommandReceived) { // <b class="conum">(2)</b>
      isCommandReceived = 0;
      HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); // <b class="conum">(3)</b>

      feedback.speed1 = motor1Control.speed; // <b class="conum">(4)</b>
      feedback.speed2 = motor2Control.speed;
      feedback.speed3 = motor3Control.speed;

      CDC_Transmit_FS(&amp;feedback, sizeof(feedback)); // <b class="conum">(5)</b>
    }
  }
  /* USER CODE END 3 */
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Define an instance of Feedback for sending data.</p>
</li>
<li>
<p>Only return data when something has been received.</p>
</li>
<li>
<p>Toggle LED to indicate that data has been received.</p>
</li>
<li>
<p>Update feedback with current motor speeds.</p>
</li>
<li>
<p>Send data over USB.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_encoders">Encoders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Motors have quadrature encoders, that output 2 signals that are 90 degrees out of phase depending on the rotation direction.
The easiest way to read encoder signals is using timer&#8217;s encoder mode.
When timer&#8217;s encoder mode is used, then PWM outputs can&#8217;t be used on the same timer for controlling motor drivers,
because timer&#8217;s counter value will be changed by encoder signals instead of clock signal.</p>
</div>
<div class="sect2">
<h3 id="_stm32cubeide_timer_configuration">STM32CubeIDE timer configuration</h3>
<div class="ulist">
<ul>
<li>
<p>Mode:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Combined Channels: Encoder Mode</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configuration:</p>
<div class="ulist">
<ul>
<li>
<p>Parameter settings:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Encoder Mode: Encoder Mode TI1 and TI2</strong></p>
<div class="paragraph">
<p>This will count all the edges from both of the timer&#8217;s inputs.</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_timer_code">Timer code</h3>
<div class="paragraph">
<p>Encoder can be enabled by calling <code>HAL_TIM_Encoder_Start</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int main(void)
{
  // ...

  /* USER CODE BEGIN 2 */
  HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_1 | TIM_CHANNEL_2);
  /* USER CODE END 2 */

  // ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Current encoder value can be read from timer&#8217;s counter register.
It is useful to have timer&#8217;s autoreload register value at 65535, which is the highest 16-bit value
and cast encoder value to signed 16-bit integer (int16_t).
If all the encoder timers are 32-bit, then it might be more useful to do the same with 32-bit types.
Casting to signed integer allows for a simple encoder value change calculation in both negative and positive directions.
Encoder value (position) change can be used as a speed feedback in motor control.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int16_t position = (int16_t)TIM1-&gt;CNT;
int16_t positionChange = position - positionPrev;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pwm">PWM</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_stm32cubeide_timer_configuration_2">STM32CubeIDE timer configuration</h3>
<div class="ulist">
<ul>
<li>
<p>Mode:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Channel#: PWM Generation CH#</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configuration:</p>
<div class="ulist">
<ul>
<li>
<p>Parameter settings:</p>
<div class="ulist">
<ul>
<li>
<p>Counter settings:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Prescaler: see below</strong></p>
</li>
<li>
<p><strong>Counter period: see below</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_frequency">Frequency</h3>
<div class="paragraph">
<p>Frequency of each timer can be calculated from prescaler register value (PSC)
and counter period/autoreload register value (ARR) with a following formula:</p>
</div>
<div class="paragraph">
<p>\$f = f_(clock) / ((PSC + 1) (AR\R + 1)\$</p>
</div>
<div class="paragraph">
<p><em>f<sub>clock</sub></em> is the timer clock, that can be found and configured from <strong>Clock configuration</strong> page in STM32CubeIDE,
where it is referred to as <em>APB1 timer clocks</em> or <em>APB2 timer clocks</em>.</p>
</div>
<div class="paragraph">
<p>To see if timer is connected to APB1 or APB2, refer to <em>Figure 1. STM32G441xB block diagram</em> in the datasheet or
<em>7.4.17 APB1 peripheral clock enable register 1 (RCC_APB1ENR1)</em> and
<em>7.4.19 APB2 peripheral clock enable register (RCC_APB2ENR)</em> in the reference manual.</p>
</div>
<div class="paragraph">
<p>All PWM outputs of a timer share the same frequency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pwm_for_wheel_motor_drivers">PWM for wheel motor drivers</h3>
<div class="paragraph">
<p>Each motor driver needs 2 PWM inputs or 1 PWM and 1 direction input.
Recommended way for pre-production DRV8243 motor drivers is to use 1 PWM and 1 direction input.</p>
</div>
<div class="paragraph">
<p>If PSC = 0, ARR = 65535, <em>f<sub>clock</sub></em> = 160 MHz, then <em>f<sub>PWM</sub></em> &asymp; 2448 Hz,
which is suitable frequency for motor drivers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pwm_for_thrower_motor_driver">PWM for thrower motor driver</h3>
<div class="paragraph">
<p>Usually brushless ESCs are controlled by single PWM signal with frequency of 50 Hz (period = 20 ms)
and pulse width between 1 ms and 2 ms.
Often higher frequencies and shorter pulse width are supported.</p>
</div>
<div class="paragraph">
<p>Newer ESCs also support DShot protocol, which is a digital protocol as opposed to regular PWM being analog.</p>
</div>
<div class="paragraph">
<p>DShot can be implemented with 1 PWM output and DMA.</p>
</div>
<div class="paragraph">
<p><a href="https://dmrlawson.co.uk/index.php/2017/12/04/dshot-in-the-dark/">More information about DShot</a></p>
</div>
<div class="paragraph">
<p>Timer for thrower motor PWM should be separate from wheel motor PWM timers to be able to use different frequency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pwm_code">PWM code</h3>
<div class="paragraph">
<p>PWM can be enabled by calling <code>HAL_TIM_PWM_Start</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int main(void)
{
  // ...

  /* USER CODE BEGIN 2 */
  HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);
  /* USER CODE END 2 */

  // ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>PWM duty cycle can be changed by writing to timer&#8217;s capture/compare register.
Duty cycle can range from 0 to the value specified in autoreload register.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">TIM2-&gt;CCR1 = 9500; // Timer 2, channel 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_motor_control">Motor control</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_periodic_interrupt">Periodic interrupt</h3>
<div class="paragraph">
<p>Using fixed period for calculations simplifies motor control by allowing to omit time from calculations.</p>
</div>
<div class="paragraph">
<p>Timer can be used to generate periodic interrupts.
Calculations can be done in interrupt handler.</p>
</div>
<div class="paragraph">
<p>Prescaler and autoreload registers need to be configured under <em>Parameter Settings</em> to set the frequency of interrupts.
Good frequency could be 100 Hz.
Higher frequencies reduce the number of encoder changes between interrupts
and lower frequencies reduce the motor control responsiveness.</p>
</div>
<div class="paragraph">
<p>Timer (global or update) interrupt can be enabled under <em>NVIC Settings</em>.
Update interrupt is generated every time the timer&#8217;s counter register overflows from autoreload register value to 0.</p>
</div>
<div class="paragraph">
<p>Timer can be enabled by calling <em>HAL_TIM_Base_Start_IT</em>.</p>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// ..
HAL_TIM_Base_Start_IT(&amp;htim6);
/* USER CODE END 2 */</code></pre>
</div>
</div>
<div class="paragraph">
<p>Timer&#8217;s update interrupt can be defined
by implementing <em>HAL_TIM_PeriodElapsedCallback</em> function from <em>stm32g4xx_hal_tim.c</em>.
It is usually not recommended to have long-running code in interrupt handler,
but since motor control code is time sensitive (by omitting time from calculations)
and there is no other computation done at the same time,
it is fine to have it in interrupt handler.</p>
</div>
<div class="listingblock">
<div class="title">main.c</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
  // Motor control calculations can be called from here
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pid_controller">PID controller</h3>
<div class="paragraph">
<p>Motor speed control can be implemented with a PID controller.
Just a PI controller, where derivative part is not implemented/used, is usually also fine when controlling motor speed.</p>
</div>
<div class="paragraph">
<p>Encoder changes can be used as a speed feedback.
Setpoints can be received through the USB communication.
Output of the controller should be PWM for a motor driver.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_boot_configuration">Boot configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Boot configuration is detailed in
<a href="https://www.st.com/resource/en/reference_manual/dm00355726-stm32g4-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">reference manual</a>
under <em>2.6 Boot configuration</em> section.</p>
</div>
<div class="paragraph">
<p>nSWBOOT0 bit in FLASH_OPTR registry determines
whether BOOT0 pin (when nSWBOOT0 = 1) or nBOOT0 in FLASH_OPTR registry (when nSWBOOT0 = 0)
is used to select boot mode.</p>
</div>
<div class="paragraph">
<p>BOOT0 can be left unused or used for some other function if nSWBOOT0 is set to 1 in FLASH_OPTR registry.</p>
</div>
<div class="paragraph">
<p>One option to check and change FLASH_OPTR registry settings is to use STM32CubeProgrammer and Option Bytes in there.</p>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>